module Backend.InstructionSelection where

import Backend.Tree as B
import Backend.Names
import Backend.MachineSpecifics
import Backend.DummyMachine
import Backend.Cmm
import Control.Monad.Trans.Writer.Strict


munchExp :: (MachineSpecifics m a f)=> B.Exp -> WriterT [a] m Temp

munchExp (B.CONST a) = do -- überhaupt nötig?
	t <- nextTemp
	tell [OPER2 ENTER (Reg t) (Imm a)]
	return t

munchExp (B.BINOP (B.CONST a) b) = do 
	t <- nextTemp
	b <- munchExp b
	tell [OPER2 MOV (Reg t) (Imm a)]
	tell [OPER2 ADD (Reg t) (Reg b)]
	return t

munchExp (B.BINOP b (B.CONST a)) = do 
	t <- nextTemp
	b <- munchExp b
	tell [OPER2 MOV (Reg t) (Imm a)]
	tell [OPER2 ADD (Reg t) (Reg b)]
	return t

munchExp (B.BINOP op a b) = do 
	t <- nextTemp
	a <- munchExp a
	b <- munchExp b
	tell [OPER2 MOV (Reg t) (Reg a)]
	tell [OPER2 ADD (Reg t) (Reg b)]
	return t

munchExp (B.NAME a) = do
	lab <- mkNamedLabel a
	return lab

munchExp (B.TEMP a) = do
	t <- mkNamedTemp a
	return t

munchExp (B.MEM a) = do
	t <- nextTemp
	tell [OPER2  MOV (Reg t) (Mem (Just a) 0 Nothing)]
	return t

munchExp (B.CAll f args) = do -- ?
	t <- nextTemp
	f <- munchExp f
	args <- mapM munchExp args
	tell [OPER1 CALL (Reg f)]
	return t




munchStm :: (MachineSpecifics m a f)=> B.Stm -> WriterT [a] m ()

munchStm (B.EXP (B.CALL f args)) = -- ?

munchStm (B.EXP exp) = munchExp exp >>= (\ _ -> return ())

munchStm (B.MOVE dest src) = do 
	dest <- munchExp dest
	src <- munchExp src
	tell [OPER2 MOV (Reg dest) (Reg src)]

munchStm (B.JUMP dest poss) = tell [JMP dest] -- ?

munchStm (B.CJUMP rel e1 e2 trueLab falseLab) = do
	e1 <- munchExp e1
	e2 <- munchExp e2
	tell [OPER2 CMP (Reg e1) (Reg e2)]
	let rel' = case rel of B.EQ -> E 
									| B.NE -> NE 
									| B.LT -> L
									| B.GT -> G
									| B.LE -> LE
									| B.GE -> GE
									| B.ULT -> L
									| B.ULE -> LE
									| B.UGT -> G
									| B.UGE -> GE
	lab <- mkNamedLabel trueLab
	tell [J rel' lab]

munchStm (B.LABEL lab) = do
	lab <- mkNamedLabel lab
	tell [LABEL Label]

munchStm (B.NOP) = tell [NOP]


{-
data Stm
  = MOVE  { dest :: Exp, src :: Exp }
  | EXP   { exp  :: Exp }
  | JUMP  { dest :: Exp, poss :: [Label] }
  | CJUMP { rel :: RelOp, leftE :: Exp, rightE :: Exp, trueLab :: Label, falseLab :: Label }
  | SEQ   { first :: Stm, second :: Stm }
  | LABEL { label :: Label }
  | NOP -}
